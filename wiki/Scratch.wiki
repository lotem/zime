#summary very casual design notes
#labels Phase-Design

= Rhyme 第一日 =

我知道。应该这样做：

  * 写一个 rhyme.ime，其实是个DLL，用C++写，提供IME API指定的几个函数。
  * 在那里面，启动一个后台程序：
    python rhyme.py -d
  * 然后用Socket连接过去。
  * rhyme.py随即为这个客户程序生成一个Session，包含一个独立的输入法引擎实例。
  * DLL里的键盘事件处理函数把事件发送给rhyme.py，
  * rhyme.py 传回输入法引擎的处理结果：
      * commit_string,  // 输入法输出
      * preedit,  // 预编辑字符串
      * aux_string,  // 
      * candidate_list //
  * DLL据此组织输出，并更新界面。

  * UI 也是写在DLL里。可能用到WTL？

我想先弄个简约一点的UI。
{{{
 --------------
 preedit
 aux_string
 candidate_list
 --------------
}}}

狂想：

可能嵌入式的preedit难做一点，干脆先显示到输入法的窗口上，也不必跟随光标，直接放在屏幕正中，用极大号字，半透明窗体，白色，黑边框，符合ZIME图标的水墨风格。

= Rhyme 第二日 =

Rhyme IME客户端，用C++开发。

class !RhymeClient  实现与后台服务的通信，Socket
  * static bool !CheckService()  检查、启动后台服务
  * !StartSession()  连接后台服务，开始会话
  * !EndSession()  结束会话，中断连接
  * Msg !ProcessKeyEvent(keycode, mask)  通过后台服务处理键盘事件，通信协议见下文

class !RhymePanel  绘制用户界面，用WTL或Win32 API做一个窗体
  * Show()  显示输入法界面
  * Hide()  隐藏界面
  * Update(Msg)  更新界面
  * preedit  预编辑串（中文句子）
  * auxString  辅助码（选定单词的拼音）
  * candidates  候选列表

IME API  DLL导出函数（请高人执笔？）

!RhymeDemo  先制成一个演示程序，测验IME客户端的功能。
显示一个文本框，调用 !RhymeClient 和 !RhymePanel 干活。

== 后台服务 ==

服务部分用Python写，重用现有的ZIME算法。

环境变量：

PATH  Python解释器路径，形如 C:\Python26\bin
HOME  数据库文件放在 %HOME%/.ibus/zime/zime.db，可以把HOME设置到Rhyme的根目录，或当前用户的主目录。

script rhyme.py: 以pythonw.exe调用

class !RhymeService
  * spawn Rhyme session -> create a separate Engine instance
  * shared DB (reuse ibus-zime modules)

通信消息：
{{{
// to service
EVENT=<int keycode>,<int mask>
// from service
COMMIT=<unicode>
PREEDIT=<unicode>
AUX=<unicode>
CANDIDATES=5
<uincode>
<uincode>
<uincode>
<uincode>
<uincode>
RET=true/false
}}}