#summary 拼寫運算技術詳解
#labels Featured,Phase-Support

中州韻輸入平台(ZIME)一項獨創的核心技術是*拼寫運算*機制 (Spelling Algebra)。
所謂拼寫運算，即通過一組規則建立單字表中的編碼與可由用戶輸入的拼式之間的映射關係。

首先解釋幾個概念。

每種輸入方案用到一張單字編碼表，這裡面準確地說是記錄了所有的單個音節的編碼，及其對應的文字。
由於同音字和多音字的存在，編碼與文字之間是多對多的關係。
而文字不必是單個漢字，只要對應與單個音節即可。
這是我首先要明確的基礎概念，單個音節的編碼，下文稱為鍵字 (keyword)，每個鍵字對應一個文字 (word) 的集合，即一組同音字。

實際輸入過程，可以採取單字、詞組、整句的方式，因此用戶的輸入是多個編碼的序列。
其中某些編碼的序列在詞庫中有記錄，是一個由方案定義的詞語。
我把若干個鍵字的序列稱為鍵 (key)，詞庫，即是以鍵來做詞語 (phrase) 的索引。

接著分析一下ZIME實現輸入的過程。

  * 一、用戶發出的鍵盤事件，經過解析器編成輸入碼的序列。輸入碼取自鍵盤上的可打印字符。如果想要對輸入碼進行一些有規律的變形，比如把特定編碼組合變成帶調號的字母，可借助於拼寫運算機制。
  * 二、每種輸入方案都有固定的可接受的音節拼式集合。據此，程序嘗試對輸入碼的序列進行音節切分。音節切分的結果有可能不惟一，這往往是隔音問題造成的。
  * 三、音節切分得到一個拼式 (spelling) 的序列，將每個拼式映射為鍵字，再窮舉所有的鍵，到詞庫中查詢候選的詞語。這裡揭示了一個問題，用戶輸入的拼式，可能不同於鍵字，而通過拼寫運算機制映射為鍵字。
  * 四、詞庫內的數據是在配置輸入方案時寫入的，每個鍵對應一組同音詞。作為詞庫索引的鍵，也不是直接由單字編碼表中的鍵字組成。不妨以索引鍵 (ikey) 和原始鍵 (okey) 做稱謂上的分別。索引鍵字是在環節三裡使用到的鍵字。因此在配置輸入方案的時候，預先通過拼寫運算把所有原始鍵字映射為索引鍵字。增加這個層次是為了使方案能在單字編碼表所列音系的基礎上作出調整而不必改動碼表，譬如增設模糊音。

可見，拼寫運算機制應用於輸入的各個環節。它是一系列編碼的變換規則。分為：
  * !MappingRule, !FuzzyRule 此二者作用於環節四。
  * !SpellingRule, !AlternativeRule 此二者作用於環節三。
  * !TransformRule 作用於環節一。

圖示配置輸入方案過程：
{{{
原始鍵字 --(M)(F)--> 索引鍵字（用於詞庫索引） --(S)(A)--> 可接受的音節拼式（用於音節切分）
}}}
圖示打字過程：
{{{
鍵盤事件 --> 字符序列 --(T)--> 輸入碼序列 --> 音節拼式序列 --> 索引鍵 --> 候選詞
}}}

為啥這麼複雜？因為裡面的每個機關所提供的功能，都是實現輸入平台最大程度的靈活性所需。
聽我一一解讀。

----

假設我有單字表`demo-keywords.txt`：
{{{
zhen	真
zheng	正
jing	淨
zeng	增
}}}

{{{
MappingRule = ^zh jh
}}}
將拼式開頭的zh替換為jh。結果為：
{{{
索引鍵字 jhen --> 真
索引鍵字 jheng --> 正
索引鍵字 jing --> 淨
索引鍵字 zeng --> 增
}}}

規則的寫法 `MappingRule = abc xyz`

等號後面是以空格區分的正則表達式abc和替換字符串xyz。如果某個拼式與abc的形式相匹配，則將該拼式的匹配部份改寫為xyz。
正則表達式是一種對文字進行通配的表示法。裡面設置了一些特殊意義的符號，比如^匹配字符串的起始位置。不熟悉的朋友可以在網絡上查找相關資料學習。

通過上式，把單字表中的漢語拼音聲母zh變換為通用拼音的表示法jh。
再添加幾條規則，變形其他的聲母：
{{{
MappingRule = ^zh jh
MappingRule = ^([jcs]h|[rzcs])i$ \1ih
MappingRule = ^qi ci
MappingRule = ^xi si
}}}
後兩條將q, x變形為ci-, si-的形式。但要小心，這樣一來音節qi, xi就變成ci, si而與漢語拼音中原本存在的「此」「四」混同。
因此在q, x的變形之前，要先變換韻母-ih。即第二條規則。這個規則寫起來有些複雜，用到了幾種正則式的特殊字符：
( ) 裡面那部份正則式，匹配聲母 jh, ch, sh, r, z, c, s。| 是「或」的意思。[ ] 表示裡面幾種字符可取任意一個。
最後的 $ 表示 i 處於整個拼式的末尾。其實 ^ $ 在這裡也可以不寫，然而盡可能多做限定可加快匹配速度。

替換字符串裡的 \1 代表與 ( ) 部份匹配的文字，即原來的聲母。在有些正則表達式中不用 \1 而是寫成 $1。本品由於主要用Python編寫，採取了Python正則式的反斜線＋數字寫法。

藉這個例子說明，對於每一個拼式，依次施行所有的變換規則，規則的排序是重要的。

初學者建議寫好方案定義後，先使用這個脚本输出编码的变换结果，来验证拼寫運算规则是否正确。

    http://zime.googlecode.com/svn/trunk/zime-data/translate-keywords.py

!MappingRule的另一項用途是合併某些音節。
有人講了，我們不需要 zh, ch, sh，希望一律用 z, c, s 輸入。還有前後鼻音也不必區分。那末，可以寫出規則：
{{{
MappingRule = ^([zcs])h \1
MappingRule = ([aeiou])ng$ \1n
}}}
拼寫運算的結果為：
{{{
索引鍵字 zen --> 真, 正, 增
索引鍵字 jin --> 淨
}}}
可以看出!MappingRule使拼式 p 變為新形式 q，且原來的形式 p 不再可用。

而通常的模糊音設置，往往還要保留原來的拼法，更多的是兩種拼法通用。這要用到另一種規則。

----

{{{
FuzzyRule = ^([zcs])h \1
}}}
!FuzzyRule將匹配的拼式所對應的文字，加入替換後拼式對應的文字集合，而原有的拼式保持不變。單字表應用上面一條規則後：
{{{
索引鍵字 zhen --> 真
索引鍵字 zheng --> 正
索引鍵字 jing --> 淨
索引鍵字 zen --> 真
索引鍵字 zeng --> 正, 增
}}}
可見這裡發生了兩種情況。zhen 替換為 zen，這是一個全新的拼式，它與 zhen 是完全等價的；zheng 替換為 zeng，這個拼式本已存在，於是 zheng 所轄的字併入 zeng 音，而 zheng 仍保持可用。

又有人反映，模糊音不應該是單向的，打 zh 也應該給出 z 字頭的字。於是規則修改為：
{{{
FuzzyRule = ^([zcs])h \1
FuzzyRule = ^([zcs]) \1h
}}}
變換的過程是這樣，先對所有拼式應用第一條規則，zh, ch, sh 混入 z, c, s，鍵字與文字的對應關係成為如下情形：
{{{
zhen --> 真
zheng --> 正
jing --> 淨
zen --> 真
zeng --> 正, 增
}}}
產生了一個與 zhen 等價的新鍵字 zen，zheng 併入 zeng。再對這些結果中的拼式應用第二條規則，得到：
{{{
索引鍵字 zhen --> 真
索引鍵字 zheng --> 正, 增
索引鍵字 jing --> 淨
索引鍵字 zen --> 真
索引鍵字 zeng --> 正, 增
}}}
這裡的拼寫運算解讀為，已經是模糊音的 zen 與 zeng 再分別混入 zhen, zheng 兩音，結果 zhen 沒有變化， zheng 獲得了原 zeng 音的候選字。
至此達到了 zh, z 兩可的模糊音效果。簡拼中的音序輸入、可選的聲調輸入也可視為模糊音的特例，用!FuzzyRule來實現。

方案定義文件中，!MappingRule於!FuzzyRule的定義順序任意，然而!FuzzyRule總是在所有!MappingRule之後執行。
上例的最終拼式，zhen, zheng, jing 將用於詞庫索引，而 zen 與 zhen、zeng 與 zheng 對應到相同的候選字集合，可視作異拼，因此不再生成重複的索引項。

----

再接著，可以使用!SpellingRule對索引鍵字進行進一步的變形，從而改變實際輸入所用到的拼寫法。
!SpellingRule與!MappingRule的寫法和執行方式完全相同。把前文漢語拼音轉通用拼音的例子改寫為!SpellingRule：
{{{
SpellingRule = ^zh jh
SpellingRule = ^([jcs]h|[rzcs])i$ \1ih
SpellingRule = ^qi ci
SpellingRule = ^xi si
}}}
它與!MappingRule的區別在於執行的時機，是在詞庫索引完成後。因此，使用!SpellingRule實現的通用拼音輸入方案，其索引鍵字仍然是漢語拼音的拼式，因此可以和漢語拼音輸入方案共享一套詞庫。若以!MappingRule來做拼式的變換，則只好使用獨立的詞庫，這不僅浪費存儲空間，還失去了兩種方案共享用戶詞典的機會。

----

!SpellingRule之後可定義與!FuzzyRule相對應的!AlternativeRule。它的主要用途是增設異拼、拼寫糾錯等兼容的拼寫形式。

在如下漢語拼音單字表上，實現兼容的尖團音拼寫：
{{{
ji	集
jie	節
jin	進
jing	淨
jiu	就
ju	聚
zi	字
}}}
有規則：
{{{
AlternativeRule = ^j zy
AlternativeRule = ^zy(i.+)$ z\1
AlternativeRule = ([aeiou])ng$ \1gn
}}}
第一條規則產生與 j 等價的尖音拼寫 zy：
{{{
ji, zyi	集
jie, zyie	節
jin, zyin	進
jing, zying	淨
jiu, zyiu	就
ju, zyu	聚
zi	字
}}}
第二條規則簡化那些zy後面跟隨著介音i的拼式，省略字母y。但拼式zyi不作省略，以避免與既有的音節「字」混同。
{{{
ji, zyi	集
jie, zyie, zie	節
jin, zyin, zin	進
jing, zying, zing	淨
jiu, zyiu, ziu	就
ju, zyu	聚
zi	字
}}}
用戶輸入過程中，所有 zie, zin, zing, ziu 以及 zy- 系列都映射為等價的 j- 模樣的鍵字進行詞庫檢索。

第三條規則是拼寫糾錯的措施，把誤打成 -ign 的拼式映射到 -ing：
{{{
jing, zying, zing, jign, zyign, zign	淨
}}}

總結一下拼寫運算中的以上四類規則。從單字表中的原始鍵字出發，按照應用的順序依次為：
  * !MappingRule 可實現拼式的多對一映射，合併某些音節種類，也可用作一對一映射，改換拼寫法。
  * !FuzzyRule 多對多映射，主要用於模糊音設置。
多對一的映射關係意味著音節種類的合併，即產生新的候選字集合。這樣的拼寫運算必須在生成詞庫索引之前完成。因此在以下兩樣規則中嚴格禁止。
  * !SpellingRule 一對一映射，改換拼寫法。
  * !AlternativeRule 一對多映射，產生新的兼容拼式。

這四類拼寫運算都是在配置輸入方案時以及開啟輸入法的初始化階段應用。計算出的拼式－鍵字映射表用於在輸入過程中快速完成變換。

另一種規則，羅馬字解析器中的!TransformRule是從輸入碼序列出發，在音節切分操作之前執行變換。它操作的對象是整個輸入碼序列，而不是單個音節拼式。故規則中通常不寫 ^ $ 。
它的用途包括，由輸入碼生成鍵盤以外的字符。看這一規則代碼片段：
{{{
TransformRule = ([aeiou])(ng?)([1-5]) a\2\1
TransformRule = a4 à
TransformRule = i4 ì
}}}

假使我鍵入的輸入碼序列是 `mian4xiang4dui4xiang4`，應用規則一，調號移至主要元音字母後，變形為 `mia4nxia4ngdui4xia4ng`；可見!TransformRule會依次應用於輸入碼序列中的所有匹配。

繼而應用規則二給a標調，得 `miànxiàngdui4xiàng`；應用規則三給i標調，最終得到 `miànxiàngduìxiàng`，經過音節切分而顯示為 `miàn xiàng duì xiàng`。

另一用途是拼式糾錯：
{{{
TransformRule = ([aeiou])gn \1ng
}}}
這與!AlternativeRule的拼式糾錯效果略有不同。比方說，敲入`chagnan`，!TransformRule立即幫我糾正過來，顯示為`changan`，接著進行音節切分會有 chang'an, chan'gan 兩種解讀；而`chagnan`在!AlternativeRule的糾正下，顯示為`chagn an`，chagn 屬於可接受拼式，它是在內部處理中映射為索引鍵字 chang 的。而且由於不存在拼式 chag 或 gnan，故不會出現音節切分的歧義。

----

拼寫運算機制，為輸入方案的定義增加了無限可能。輸入方案開發者請把它與各類解析器、智能音節切分、語言模型等設施相結合，以你的想像力創造更為靈活多變的用法。